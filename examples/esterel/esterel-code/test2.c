/*
 *                               POK header
 *
 * The following file is a part of the POK project. Any modification should
 * be made according to the POK licence. You CANNOT use this file or a part
 * of a file for your own project.
 *
 * For more information on the POK licence, please see our LICENCE FILE
 *
 * Please follow the coding guidelines described in doc/CODING_GUIDELINES
 *
 *                                      Copyright (c) 2007-2025 POK team
 */

/*
  File: C:\DOCUME~1\ADMINI~1\Bureau\Default\Code/test2.c
  Date: Tue Mar 10 13:06:58 2009

  Unit: divider

  Generated by eicfastc:
               version: v7_51i24
               released: 17/07/2008
               rcs name: p288r13
    With libraries: eic (p882r14), BigNum (p38r1)
*/

/* Libraries */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Esterel header */
#include "test2_strl.h"

/* SYNC */
#define _SYNC(max_k, k) (max_k = (max_k < k ? k : max_k))

/* DSZ */
#define _DSZ(V) (V-- <= 1)

/* COND */
#define _COND(A, B, C) ((A) ? (B) : (C))

/* SENSOR_VAL */
#define _SENSOR_VAL(T, V, A) _COND(T, V, (T = _true, A, V))

/* MEMZERO */
#define _FASTC_MEMZERO(dest_ptr, byte_size) memset(dest_ptr, 0, byte_size)

/* MEMCOPY */
#define _FASTC_MEMCOPY(dest_ptr, src_ptr, byte_size)                           \
  memcpy(dest_ptr, src_ptr, byte_size)

/* Predefined functions */

/* State type */

typedef struct _divider_State {
  unsigned long _V0;
} _divider_State;

/* Execution flag type */

typedef struct _divider_Exec_Flag {
  unsigned long _V0;
} _divider_Exec_Flag;

/* Constants renamed in split runs */

/* Defined constants */

/* State variables */

_divider_State _State1;
_divider_State _State2;
_divider_State *_CurrentState = &_State1;
_divider_State *_NewState = &_State2;

/* Read and write state macros */

#define _SWITCH_0_0 ((_CurrentState->_V0 >> 0) & 0x1ul)
#define _SETPAUSE_8_0                                                          \
  { _NewState->_V0 = (_NewState->_V0 & 0xfffffffeul) | 0x1ul; }

/* Input signal variables */
unsigned long _input_signal_V0;

/* Output signal variables */
unsigned long _output_signal_V0;

/* divider/nb */
#define _Emit_Status_nb_S0_0(rhs) _input_signal_V0 |= (rhs) << 0
#define _Status_nb_S0_0 ((_input_signal_V0 >> 0) & 1)
/* divider/res */
#define _Emit_Status_res_S1_0(rhs) _output_signal_V0 |= (rhs) << 0
#define _Status_res_S1_0 ((_output_signal_V0 >> 0) & 1)

/* Input signal macros */
#define _input_status_reset _input_signal_V0 = 0;
#define _input_status_reset_and_pre_update                                     \
  _input_signal_V0 = (_input_signal_V0 << 1) & 0x0u;
/* Output signal macros */
#define _output_status_reset_and_pre_update                                    \
  _output_signal_V0 = (_output_signal_V0 << 1) & 0x0u;

/* Variables */

/* divider/?nb */
static strl_unsigned _Value_nb_S0_0;
/* divider/?res */
static strl_unsigned _Value_res_S1_0;

/* Suspend flag save variables */

/* Auxiliary bignum declarations */

/* Switch variables */

/* init done flag */
static _BIT_TYPE _divider_InitDone;

/* Input signal with status functions */

void divider_I_nb(strl_unsigned _v) {
  /* Array loop indices */

  _Value_nb_S0_0 = _v;
  _Emit_Status_nb_S0_0(_true);
}

/* Input value-only read functions */

/* split run input value-only functions */

/* split run output with status functions */

/* Execution flag definitions */

#define _Set_Go_4_0(rhs) _exec_flag._V0 |= (rhs) << 0
#define _Go_4_0 ((_exec_flag._V0 >> 0) & 1)

/* Actions */

#define _ACTION_0_0_0
#define _ACTION_3_0_0
#define _ACTION_5_0_0 _Value_res_S1_0 = (_Value_nb_S0_0 / 2u);

/* Tests */

#define _TEST_0_0 _Status_nb_S0_0

/* Reset reaction */

void divider_reset_reaction() {

  /* Iterator loop indices */

  /* Array loop indices */
}

/* Reaction */

int divider() {

  /* Execution flags */

  _divider_Exec_Flag _exec_flag = {0};

  /* Test returns */

  /* Iterator loop indices */

  /* Array loop indices */

  /* Execution */

  /* Newst_nb_S0_0 */
  /* Newval_nb_S0_0 */
  /* Switch_0_0 */
  if (_SWITCH_0_0) {
  } else {
    _ACTION_0_0_0;
    _ACTION_3_0_0;
  }
  _output_status_reset_and_pre_update;
  if (_SWITCH_0_0 == 0) {
    _Set_Go_4_0(_true);
  } else {
    /* Test_2_0_T0 */
    if (_TEST_0_0) {
      _Set_Go_4_0(_true);
    } else {
      /* Setpause_7_0_u1 */
      _SETPAUSE_8_0;
    }
  }
  if (_Go_4_0) {
    /* Equation_6_0 */
    _Emit_Status_res_S1_0(_true);
    _ACTION_5_0_0;
    /* Newst_res_S1_0 */
    if (_Status_res_S1_0) {
      divider_O_res(_Value_res_S1_0);
    }
    /* Newval_res_S1_0 */
    /* Setpause_7_0_u0 */
    _SETPAUSE_8_0;
  }

  /* Disabled variables update */

  /* Suspend flag save variables update */

  /* Input sig pre actions */

  _input_status_reset_and_pre_update;

  /* Swap states */
  {
    _divider_State *_tmp = _CurrentState;
    _CurrentState = _NewState;
    _NewState = _tmp;
  }

  divider_reset_reaction();

  return 1;
}

/* Reset */

int divider_reset() {

  /* Iterator loop indices */

  /* Array loop indices */

  if (!_divider_InitDone) {
    divider_init();
    _divider_InitDone = _true;
  }

  /* Reset of state variables */
  _CurrentState->_V0 = 0;

  _input_status_reset;
  divider_reset_reaction();

  return 0;
}

/* Unified API */

int divider_init() {
  /* Iterator loop indices */

  /* Array loop indices */

  return 1;
}

int divider_end() {
  /* Iterator loop indices */

  /* Array loop indices */

  _divider_InitDone = _false;

  return 1;
}

int divider_run() { return divider(); }
