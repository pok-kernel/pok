#### 0.项目学习和Debug

首先我们按照作者上传在Github上的教程跑通了examples/semaphores。

但我们发现examples文件夹下的所有demo都是：

1. 通过sleep函数来控制每个线程占用的时间片
2. 通过for循环表示周期性任务调度的次数

并没有使用每个Task的time_capacity，period等属性进行任务调度，这不利于我们之后的实验。于是我们先修改了semaphores，使用`pok_thread_t`中的变量进行周期性任务调度，创建了`mytests/demo`测试程序。demo中采用pok自带的static调度模式。具体任务设计如下

```c
//Task1
tattr.period = 500;
tattr.time_capacity = 60;
tattr.priority = 60;
ret = pok_thread_create(&tid, &tattr);
//Task2
tattr.period = 400;
tattr.time_capacity = 100;
tattr.priority = 50;
ret = pok_thread_create(&tid, &tattr);
//Task3
tattr.period = 500;
tattr.time_capacity = 140;
tattr.priority = 40;
ret = pok_thread_create(&tid, &tattr);
```

发现运行结果与预期并不相符。按照代码逻辑三个线程应该都会被调度到，但调度器只会在优先级较高的两个线程间来回切换。

经过debug，我们发现是pok中使用的时钟出现了冲突：计算任务剩余时间，ddl等属性的时钟与调度器(`POK_GETTICK`函数)不是同一个时钟。于是我们在`kernel\include\core\sched.h`中定义每20个tick进行一次调度（一个时间片），并修改了`kernel\arch\x86\x86-qemu\pit.c`文件，使得时钟同步。

```c
#define POK_LAB_SCHED_TIME 20
```

运行demo，发现时间片分布均匀，运行结果符合代码逻辑。

![https://ly-pok.oss-cn-hangzhou.aliyuncs.com/demo_res.png?Expires=1672910275&OSSAccessKeyId=TMP.3KdGvFS1sX2DgGHSqnqhHg5wMkHoetg2C8TKDWyef9VXcUX2XohkLKifpxWaohj6JY3aw9dS7UwHc2CwcW47ky7JUFLjA9&Signature=BaHHt8DVYt%2BrhqxMTl%2BizUlhVrI%3D](https://ly-pok.oss-cn-hangzhou.aliyuncs.com/demo_res.png?Expires=1672910275&OSSAccessKeyId=TMP.3KdGvFS1sX2DgGHSqnqhHg5wMkHoetg2C8TKDWyef9VXcUX2XohkLKifpxWaohj6JY3aw9dS7UwHc2CwcW47ky7JUFLjA9&Signature=BaHHt8DVYt%2BrhqxMTl%2BizUlhVrI%3D)

终端上的结果在每次线程切换时才会打印，并不能表示每个线程占了多少时间片，可读性较差。因此我们对后续的测试打印进行了修改润色，具体内容在测试报告中。

#### 1.四种调度算法

新建了`kernel\core\my_sched.c`文件来实现实验中的调度算法。

在kernel\include\core\schedvalues.h 26行新增新的调度选项

```c
 POK_MY_SCHED_PRIO = 7,
 POK_MY_SCHED_EDF = 8,
 POK_MY_SCHED_RR = 9,
 POK_MY_SCHED_WRR = 10
```

在partition.c 70行增加新的case

```c
//抢占式优先级调度，其余省略。
case POK_MY_SCHED_PRIO:
  pok_partitions[pid].sched_func = &pok_my_sched_part_prio;
  break;
```

##### 1.1 抢占式优先级调度

遍历处理器下的所有线程，比较每个线程的priority属性，选中状态为Runnable且优先级最高的线程进行执行。具体实现如下：

```c
  uint32_t elected, from;
  uint8_t current_proc = pok_get_proc_id();
  uint32_t res = IDLE_THREAD;
  from = current_thread == IDLE_THREAD? prev_thread:current_thread;
  elected = from;
  do {
      if (pok_threads[elected].state == POK_STATE_RUNNABLE && 
      pok_threads[elected].priority>pok_threads[res].priority) {
            res = elected;
        }
        elected++;
        if (elected >= index_high) {
          elected = index_low;
        }
    } while (elected != from);
```

##### 1.2 抢占式EDF

我们后面的实验需要进行周期性调度，因此需要维护相对ddl和绝对ddl。

在`kernel\include\core\thread.h`中为`pok_thread_t`结构体新增ab_deadline变量，并进行相应的初始化。

在`kernel\core\sched.c` （218行）进行ab_deadline的更新，每次周期性任务调度结束后，更新新的绝对ddl为下一次的激活时间 + 相对ddl。

```c
thread->ab_deadline = thread->next_activation + thread->deadline;
```

其余逻辑与抢占式优先级逻辑基本相同。遍历处理器下的所有线程，比较每个线程的绝对ddl，选中状态为Runnable且ddl最近的线程进行执行。具体实现如下：

```c
  uint32_t elected, from;
  uint8_t current_proc = pok_get_proc_id();
  uint32_t res = IDLE_THREAD;
  from = current_thread == IDLE_THREAD? prev_thread:current_thread;
  elected = from;
  do {
      if (pok_threads[elected].state == POK_STATE_RUNNABLE
      &&pok_threads[elected].ab_deadline<pok_threads[res].ab_deadline) {
            res = elected;
        }
        elected++;
        if (elected >= index_high) {
          elected = index_low;
        }
    } while (elected != from);
```

##### 1.3 Round-Robin与Weighted-Round-Robin

在`kernel\include\core\sched.h`中定义默认round数：

```c#
#ifndef POK_LAB_SCHED_ROUND
#define POK_LAB_SCHED_ROUND 3
#endif
```

在`kernel\include\core\thread.h`中为`pok_thread_t`结构体新增：

```c
//wrr中的权重
  uint8_t weight;
//剩余round数
  uint8_t remaining_round;
```

由于weight需要在调度时进行指定，在`kernel\include\core\thread.h`和`libpok\include\core\thread.h`中的`pok_thread_attr_t`结构体也要添加`weight`

对于wrr，只需要在每次初始化剩余round数时将默认数乘上对应的权重值。因此我们将两个调度函数合并成一个，通过一个布尔值`is_wrr`判断在更新时是否需要乘上对应的权重值。

调度时，首先判断当前线程是否可运行并有剩余round没有运行完，有则继续执行；

否则，挑选下一个可运行的线程，并将线程的剩余round数初始化。

具体实现如下：

```c
uint32_t my_rr(const uint32_t index_low, const uint32_t index_high,
                           const uint32_t prev_thread,
                           const uint32_t current_thread, const bool_t is_wrr) {
  
  
  uint32_t elected, from;
  uint8_t current_proc = pok_get_proc_id();
  uint32_t res = IDLE_THREAD;

  from = current_thread == IDLE_THREAD? prev_thread:current_thread;
  elected = from;
  if (elected != IDLE_THREAD && 
  (pok_threads[elected].state == POK_STATE_RUNNABLE)&&
  pok_threads[elected].remaining_round > 0){
    res = elected;  
    pok_threads[elected].remaining_round--; 
  }
  else{
    do {
      elected++;
      if (elected >= index_high) {
        elected = index_low;
      }
      if(pok_threads[elected].state == POK_STATE_RUNNABLE){
        res = elected;
        break;
      }
    } while (elected != from);
    if(res != IDLE_THREAD){
      if(is_wrr){
        pok_threads[res].remaining_round = POK_LAB_SCHED_ROUND*pok_threads[res].weight;
      }
      else{
        pok_threads[res].remaining_round = POK_LAB_SCHED_ROUND;
      }
      pok_threads[res].remaining_round --;
    }
  }
}
```

