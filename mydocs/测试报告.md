# 测试报告

#### 1.多线程调度

在pok中，每个线程被唤醒时会额外占一个时间片（上下文切换占用的时间），该时间片不在time_capacity中。在我们的实验环境中，规定每个时间片为20个time unit。

我们的测试在examples/semaphores基础上进行了修改。在以下的多线程调度场景中，设置分区数为1，使用单处理器（Processor 0）进行调度。

```c
#define POK_CONFIG_NB_PARTITIONS 1
#define POK_CONFIG_NB_PROCESSORS 1
```

运行结果会在qemu窗口打印，具体的打印逻辑在调度函数中。如下为抢占式优先级测试打印的部分结果

```
P0T1: Start scheduling (priority: 60) at 20
P0T1: Remaining time:40 (priority: 60) at 40
P0T1: Remaining time:20 (priority: 60) at 60
```

以第一行为例，其中P0T0表示0号处理器的线程1，60为当前线程的优先级。20表示当前时间点。

"Start scheduling"表示线程被唤醒，唤醒会占一个时间片。

"Remaining time"记录当前线程的剩余时间数。

##### 1.1 抢占式优先级调度

创建如下三个线程：

```c
 //T1
  tattr.period = 500;
  tattr.time_capacity = 60;
  tattr.priority = 60;
  ret = pok_thread_create(&tid, &tattr);
//T2
  tattr.period = 400;
  tattr.time_capacity = 100;
  tattr.priority = 50;
  ret = pok_thread_create(&tid, &tattr);
//T3
  tattr.period = 500;
  tattr.time_capacity = 140;
  tattr.priority = 40;
  ret = pok_thread_create(&tid, &tattr);
```

我们期望的结果是优先级（priority）大的线程优先运行。除去wakeup占据的时间片，T1会应该先执行3个时间片，而后T2执行5个时间片，T3执行7个时间片。在第20个时间片（即Time at 400）时，T2被再次唤醒，然后执行4个时间片，知道time at 500时T1再次被唤醒并抢占执行。

```tex
P0T1: Start scheduling (priority: 60) at 20
P0T1: Remaining time:40 (priority: 60) at 40
P0T1: Remaining time:20 (priority: 60) at 60
P0T1: Remaining time:0 (priority: 60) at 80
P0T2: Start scheduling (priority: 50) at 100
P0T2: Remaining time:80 (priority: 50) at 120
...
P0T2: Remaining time:0 (priority: 50) at 200
P0T3: Start scheduling (priority: 40) at 220
...
P0T3: Remaining time:0 (priority: 40) at 360
Idle at 380.
P0T2: Start scheduling (priority: 50) at 400
P0T2: Remaining time:80 (priority: 50) at 420
P0T2: Remaining time:60 (priority: 50) at 440
P0T2: Remaining time:40 (priority: 50) at 460
P0T2: Remaining time:20 (priority: 50) at 480
P0T1: Start scheduling (priority: 60) at 500
P0T1: Remaining time:40 (priority: 60) at 520
...
```

结果符合预期。

##### 1.2 抢占式EDF

创建如下三个线程,deadline表示线程的相对ddl：

```c
 //T1
  tattr.period = 200;
  tattr.deadline = 120;
  tattr.time_capacity = 60;
  ret = pok_thread_create(&tid, &tattr);
//T2
  tattr.period = 400;
  tattr.deadline = 400;
  tattr.time_capacity = 100;
  ret = pok_thread_create(&tid, &tattr);
//T3
  tattr.period = 500;
  tattr.deadline = 500;
  tattr.time_capacity = 140;
  ret = pok_thread_create(&tid, &tattr);
```

按照EDF策略，T1的deadline最早，应该T1先被唤醒，然后运行3个时间片，然后T2被唤醒，运行5个时间片。在时间为200时，由于T1的绝对ddl为320，提前于T2和T3的ddl，因此调度T1。而后调度T2,T3。运行后产生的结果如下：

```
P0T1: Start scheduling (deadline: 120) at 20
P0T1: Remaining time:40 (deadline: 120) at 40
P0T1: Remaining time:20 (deadline: 120) at 60
P0T1: Remaining time:0 (deadline: 120) at 80
P0T2: Start scheduling (deadline: 400) at 100
P0T2: Remaining time:80 (deadline: 400) at 120
P0T2: Remaining time:60 (deadline: 400) at 140
P0T2: Remaining time:40 (deadline: 400) at 160
P0T2: Remaining time:20 (deadline: 400) at 180
P0T1: Start scheduling (deadline: 320) at 200
P0T1: Remaining time:40 (deadline: 320) at 220
P0T1: Remaining time:20 (deadline: 320) at 240
P0T1: Remaining time:0 (deadline: 320) at 260
P0T2: Remaining time:0 (deadline: 400) at 280
P0T3: Start scheduling (deadline: 500) at 300
P0T3: Remaining time:120 (deadline: 500) at 320
P0T3: Remaining time:100 (deadline: 500) at 340
P0T3: Remaining time:80 (deadline: 500) at 360
P0T3: Remaining time:60 (deadline: 500) at 380
P0T3: Remaining time:40 (deadline: 500) at 400
...
```

结果符合预期。

##### 1.3 Round-Robin

创建如下三个线程，采用默认参数：每个线程每个round最多运行3个时间片（包含唤醒时间。即如果线程被初次创建，则唤醒的一个时间片也占该round三个时间片中的一个）。

```c
//T1
  tattr.period = 500;
  tattr.time_capacity = 60;
  ret = pok_thread_create(&tid, &tattr);
//T2
  tattr.period = 400;
  tattr.time_capacity = 100;
  ret = pok_thread_create(&tid, &tattr);
//T3
  tattr.period = 500;
  tattr.time_capacity = 140;
  ret = pok_thread_create(&tid, &tattr);
```

按照Round-Robin策略，T1，T2，T3一次运行三个时间片，而后T1运行完本周期内最后一个时间片后再把控制权交给T2，T2运行完三个时间片后，控制权交给T3，直到被再次唤醒。

```
P0T1: Start scheduling at 20
P0T1: Remaining time:40 at 40
P0T1: Remaining time:20 at 60
P0T2: Start scheduling at 80
P0T2: Remaining time:80 at 100
P0T2: Remaining time:60 at 120
P0T3: Start scheduling at 140
P0T3: Remaining time:120 at 160
P0T3: Remaining time:100 at 180
P0T1: Remaining time:0 at 200
P0T2: Remaining time:40 at 220
P0T2: Remaining time:20 at 240
P0T2: Remaining time:0 at 260
P0T3: Remaining time:80 at 280
P0T3: Remaining time:60 at 300
P0T3: Remaining time:40 at 320
P0T3: Remaining time:20 at 340
P0T3: Remaining time:0 at 360
Idle at 380.
P0T2: Start scheduling at 400
...
```

结果符合预期。

##### 1.4 Weighted-Round-Robin

创建如下三个线程，权重分别为1，2，3。在kernel/deployment.h中设置权值为1的线程每个round能被运行的最大时间片为2。

```c
//T1
  tattr.period = 500;
  tattr.time_capacity = 60;
  tattr.weight = 1;
  ret = pok_thread_create(&tid, &tattr);
//T2
  tattr.period = 400;
  tattr.time_capacity = 100;
  tattr.weight = 2;
  ret = pok_thread_create(&tid, &tattr);
//T3
  tattr.period = 500;
  tattr.time_capacity = 140;
  tattr.weight = 3;
  ret = pok_thread_create(&tid, &tattr);
```

根据每个线程的weight值，三个线程每轮能运行的最大时间片数应分别为2，4，6。运行对应测试，结果如下：

```
P0T1: Start scheduling at 20
P0T1: Remaining time:40 at 40
P0T2: Start scheduling at 60
P0T2: Remaining time:80 at 80
P0T2: Remaining time:60 at 100
P0T2: Remaining time:40 at 120
P0T3: Start scheduling at 140
P0T3: Remaining time:120 at 160
P0T3: Remaining time:100 at 180
P0T3: Remaining time:80 at 200
P0T3: Remaining time:60 at 220
P0T3: Remaining time:40 at 240
P0T1: Remaining time:20 at 260
P0T1: Remaining time:0 at 280
P0T2: Remaining time:20 at 300
P0T2: Remaining time:0 at 320
P0T3: Remaining time:20 at 340
P0T3: Remaining time:0 at 360
Idle at 380.
P0T2: Start scheduling at 400
P0T2: Remaining time:80 at 420
...
```

结果符合预期